# Modern C++ Command Line Arguments Library

Modern C++ arguments parsing library with beautiful API. Single header. Inspired by [commander.js](https://github.com/tj/commander.js).

Supports all fundamental types and most of the standart containers. Could be used with custom value types and containers.

Short API Example:

```c++
auto b = false;
auto i = 0;
auto d = 0.0;
std::string str = ""s;
auto v = std::vector<int>{};
auto m = std::map<std::string, std::string>{};

args::options options = {
	{"-b", &b},
	{"-i", &i},
	{"-d", &d},
	{args::required, "-s", "--str", &str},
	{"-v", &v},
	{"-m", &m}
};

args::parse(argc, argv, options);
```

See [short-syntax.cpp](https://github.com/wlodzislav/args/blob/master/examples/short-syntax.cpp) for the full example.

Chain API Example:

```c++
auto b = false;
auto i = 0;
auto d = 0.0;
auto str = ""s;
auto v = std::vector<int>{};
auto m = std::map<std::string, std::string>{};

auto p = args::parser{}
	.option("-b", &b)
	.option(args::required, "-i", &i)
	.option("-d", &d)
	.option("-s", "--str", &str)
	.option(args::required, "-v", "--vector", &v)
	.option("-m", "--map", &m);

auto cmd_called = false;
auto cmd_b = false;
auto e = ""s;
p.command("cmd", "c")
	.option("-b", &cmd_b)
	.option("-e", &e)
	.action([&]() {
		cmd_called = true;
	});

p.parse(argc, argv);
```

See [chain-syntax.cpp](https://github.com/wlodzislav/args/blob/master/examples/chain-syntax.cpp) for the full example.

With autogenerated help:

```c++
auto a = ""s;
auto b = ""s;
auto c = ""s;
auto d = ""s;

auto carg1 = ""s;
auto crest = std::vector<std::string>{};
args::parser p = args::parser{}
	.name("cli-cmd")
	.description("Some text")
	.command_required()
	.option("-a", "Global option A", &a)
	.option("-b", "--bb", "Global option B", &b);

p.command("list", "l", "List command")
	.arg(args::required, "carg1", "List command arg1", &carg1)
	.rest("crest", "List command rest args", &crest)
	.option("-c", "Option C", &c)
	.option(args::required, "-d", "--dd", "Option D", &d);

p.command("get", "g", "Get command")
	.arg(args::required, "smt", "What to get", &carg1)
	.option("-h", "How to get", &c);

p.parse(argc, argv);
```

See [help.cpp](https://github.com/wlodzislav/args/blob/master/examples/help.cpp) for the full example.

Short API:

* [args::parse(argv, argc, options)](#args_parse) - Parse all options
* [args::option](#args_option) - Used for literal options creation in short syntax
* [args::options](#args_options) - Used for short syntax

Chain API:
* [args::parser{}](#args_parser)
	* [parser.name(name)](#parser.name) - Set program name for generated help
	* [parser.description(description)](#parser.description) - Set program description for generated help
	* [parser.command\_required()](#parser.command_required) - Make commands required
	* [parser.option(...)](#parser.option) - Define global option
	* [parser.arg(...)](#parser.arg) - Define global positional argument
	* [parser.rest(...)](#parser.rest) - Capture rest global positional arguments into the container
	* [parser.command(...)](#parser.command) - Define command
		* [command.option(...)](#command.option) - Define command option
		* [command.arg(...)](#command.arg) - Define command positional argument
		* [command.rest(...)](#command.rest) - Capture rest command positional arguments into the container
		* [command.action(lambda)](#command.action) - Set action for command
	* [parser.parse(argv, argc)](#parser.parse) - Parse all options, arguments and commands
		* [Exception: args::invalid\_option](#args_invalid_option)
		* [Exception: args::invalid\_option\_value](#args_invalid_option_value)
		* [Exception: args::invalid\_command\_option\_value](#args_invalid_command_option_value)
		* [Exception: args::invalid\_arg\_value](#args_invalid_arg_value)
		* [Exception: args::invalid\_command\_arg\_value](#args_invalid_command_arg_value)
		* [Exception: args::unexpected\_arg](#args_unexpected_arg)
		* [Exception: args::missing\_command](#args_missing_command)
		* [Exception: args::missing\_option](#args_missing_option)
		* [Exception: args::missing\_command\_option](#args_missing_command_option)
		* [Exception: args::missing\_arg](#args_missing_arg)
		* [Exception: args::missing\_command\_arg](#args_missing_command_arg)

Custom help generation:

* [parser.help(lambda)](#parser.help) - Set custom `--help` handler
* [parser.format\_help([indent]) -> str](#parser.format_help) - Generate help
* [parser.format\_command\_help(command\_name, [indent]) -> str](#parser.format_command_help) - Generate help for the command
* [parser.format\_usage([indent]) -> str](#parser.format_usage) - Usage section of help
* [parser.format\_args([indent]) -> str](#parser.format_args) - Arguments section of help
* [parser.format\_options([indent]) -> str](#parser.format_options) - Options section of help
* [parser.format\_commands([indent]) -> str](#parser.format_commands) - Commands section of help
* [parser.format\_command\_usage(command\_name, [indent]) -> str](#parser.format_command_usage) - Usage section of the command help
* [parser.format\_command\_args(command\_name, [indent]) -> str](#parser.format_command_args) - Arguments section of the command help
* [parser.format\_command\_options(command\_name, [indent]) -> str](#parser.format_command_options) - Options section of the command help

## Features

- [x] Commands
- [x] Multi-word commands
- [x] Global/command options
- [x] Repeated options
- [x] Global/command positional args
- [x] Capture global/command rest positional args in container
- [x] Required options, args, rest args
- [x] Require command to be called
- [x] Autogenerates `--help` documentation + for commands
- [x] Build-in error messages for invalid/required options, arguments, commands
- [x] Supports non conventional options: `-frtti, -fno-rtti, +fb`
- [x] Supports pairs `key=value` as option value
- [x] Supports any type that could be parsed with `std::stringstream`
- [x] `1, 0, true, false, on, off, yes, no` values for `bool` flags
- [x] Implicitly add `--no-flag` for `bool` flags
- [x] Supports `--`
- [x] Supports `std::vector`-like containers for repeated options
- [x] Supports `std::pair` for `key=value` option value
- [x] Supports `std::map`-like containers for repeated `key=value` option value
- [x] Any value could be passed to lambda

## Exceptions handling

To output default error messages wrap `parse(...)` in:

```c++
try {
	p.parse(argc, argv);

} catch (const std::runtime_error& err) {
	std::cout << err.what() << std::endl;
	std::exit(1);
}
```

<details>
<summary>
To handle all errors separately wrap `parse(...)` in:
</summary>

```c++
try {
	p.parse(argc, argv);

} catch (const args::invalid_option& err) {
	// when unregistered option is passed
	// use err.option

} catch (const args::invalid_command_option_value& err) {
	// when failed to parse command option value
	// use err.command, err.option and err.value

} catch (const args::invalid_option_value& err) {
	// when failed to parse option value
	// use err.option and err.value

} catch (const args::invalid_command_arg_value& err) {
	// when failed to parse command argument value
	// use err.command, err.arg and err.value

} catch (const args::invalid_arg_value& err) {
	// when failed to parse argument value
	// use err.arg and err.value

} catch (const args::unexpected_arg& err) {
	// when non captured arguments is passed
	// use err.value

} catch (const args::missing_command_option& err) {
	// only when there are required command options
	// use err.command and err.option

} catch (const args::missing_option& err) {
	// only when there are required options
	// use err.option

} catch (const args::missing_command_arg& err) {
	// only when there are required command arguments
	// use err.command and err.arg

} catch (const args::missing_arg& err) {
	// only when there are required arguments
	// use err.arg

} catch (const args::missing_command& err) {
	// only when parser.command_required() is called

}
```

See [errors.cpp](https://github.com/wlodzislav/args/blob/master/examples/errors.cpp),
[required-errors.cpp](https://github.com/wlodzislav/args/blob/master/examples/required-errors.cpp) and
[command-required-error.cpp](https://github.com/wlodzislav/args/blob/master/examples/command-required-error.cpp) for the full error handling examples.

See `make examples` output for all errors messages.

</details>

## Generated help

See [help.cpp](https://github.com/wlodzislav/args/blob/master/examples/help.cpp),
[required-command-help.cpp](https://github.com/wlodzislav/args/blob/master/examples/required-command-help.cpp) examples.

For using parts of the generated help for the custom help output see
[custom-help.cpp](https://github.com/wlodzislav/args/blob/master/examples/custom-help.cpp) example.

## args::parse(argv, argc, options) <a id="args_parse" href="#args_parse">#</a>

Used for short syntax.

```c++
void parse(int argc, const char** argv, const args::options& ptions);

```

## args::option{...} <a id="args_option" href="#args_option">#</a>

Used for short syntax.

```c++
args::option{[args::required], name, destination_ptr);
args::option{[args::required], short_name, long_name, destination_ptr);
```

* `[args::required]` `args::required_t` Set optional marker to make option required
* `name` `std::string` Short `-s`, long `--long` or non conventional `+fb, -fno-rtti`
* `short_name` `std::string` Short `-s`
* `long_name` `std::string` Long `--long`
* `destination_ptr` `T*` Set option value by pointer

All overloads example:

```c++
auto b = false;
args::options options = {
	{"-b", &b},
	{"-b", "Description", &b},
	{args::required, "-b", &b}
	{args::required, "-b", "Description", &b}
	{"-b", "--long", &b},
	{"-b", "--long", "Description", &b},
	{args::required, "-b", "--long", &b}
	{args::required, "-b", "--long", "Description", &b}
};
```

<details>
<summary>All overloads:</summary>

```c++
template<typename T>
args::option(const std::string& name, T* destination);

template<typename T>
args::option(args::required_t, const std::string& name, T* destination);

template<typename T>
args::option(const std::string& short_name, const std::string& long_name, T* destination);

template<typename T>
args::option(args::required_t, const std::string& short_name, const std::string& long_name,
	T* destination);
```
</details>

## args::options <a id="args_options" href="#args_options">#</a>

Used for short syntax.

```c++
using args::options = std::vector<option>;
```

## args::parser{} <a id="args_parser" href="#args_parser">#</a>

### parser.name(name) <a id="parser.name" href="#parser.name">#</a>

Set program name for documentation.

```c++
parser& name(const std::string& name);
```

### parser.description(description) <a id="parser.description" href="#parser.description">#</a>

Set program description for documentation.

```c++
parser& description(const std::string& description);
```

### parser.command\_required() <a id="parser.command_required" href="#parser.command_required">#</a>

If called will throw when no command is called.

```c++
parser& command_required();
```

### parser.option(...) <a id="parser.option" href="#parser.option">#</a>

```c++
parser.option([args::required], name, [description], destination_ptr);
parser.option<Value_Type>([args::required], name, [description], lambda);
parser.option([args::required], short_name, long_name, [description], destination_ptr);
parser.option<Value_Type>([args::required], short_name, long_name, [description], lambda);
```

Specify global options.

* `[args::required]` `args::required_t` Set optional marker to make option required
* `name` `std::string` Short `-s`, long `--long` or non conventional `+fb, -fno-rtti`
* `short_name` `std::string` Short `-s`
* `long_name` `std::string` Long `--long`
* `description` `std::string` Description used in help generation
* `destination_ptr` `T*` Set option value by pointer
* `lambda` `void (T)` Get option value with lambda

Note! When using `lambda` first template parameter `Value_Type` is required.

All overloads example:

```c++
auto b = false;
auto p = parser{}
	// using destination_ptr
	.option("-s", &b)
	.option("-s", "Description", &b)
	.option(args::required, "-s" &b)
	.option(args::required, "-s", "Description", &b)
	.option("-s", "--long", &b)
	.option("-s", "--long", "Description", &b)
	.option(args::required, "-s", "--long", &b)
	.option(args::required, "-s", "--long", "Description", &b)

	// non conventional options with destination_ptr
	.option("+fw-tf", &b)
	.option("+fw-tf", "Description", &b)
	.option(args::required, "+fw-tf" &b)
	.option(args::required, "+fw-tf", "Description", &b)

	// using lambda
	.option<bool>("-s", [&](auto v) { b = v; })
	.option<bool>("-s", "Description", [&](auto v) { b = v; })
	.option<bool>(args::required, "-s" [&](auto v) { b = v; })
	.option<bool>(args::required, "-s", "Description", [&](auto v) { b = v; })
	.option<bool>("-s", "--long", [&](auto v) { b = v; })
	.option<bool>("-s", "--long", "Description", [&](auto v) { b = v; })
	.option<bool>(args::required, "-s", "--long", [&](auto v) { b = v; })
	.option<bool>(args::required, "-s", "--long", "Description", [&](auto v) { b = v; })

	// non conventional options with lambda
	.option("+fw-tf", [&](auto v) { b = v; })
	.option("+fw-tf", "Description", [&](auto v) { b = v; })
	.option(args::required, "+fw-tf" [&](auto v) { b = v; })
	.option(args::required, "+fw-tf", "Description", [&](auto v) { b = v; });
```

<details>
<summary>All overloads</summary>

```c++
template<typename T>
args::parser& option(const std::string& name, T* destination);

template<typename T>
args::parser& option(args::required_t, const std::string& name, T* destination);

template<typename T, typename F>
args::parser& option(const std::string& name, F handler);

template<typename T, typename F>
args::parser& option(args::required_t, const std::string& name, F handler);

template<typename T>
args::parser& option(const std::string& short_name, const std::string& long_name_or_desc,
	T* destination);

template<typename T>
args::parser& option(const std::string& short_name, const std::string& long_name,
	const std::string& description, T* destination);

template<typename T>
args::parser& option(args::required_t, const std::string& short_name,
	const std::string& long_name_or_desc, T* destination);

template<typename T>
args::parser& option(args::required_t, const std::string& short_name, const std::string& long_name,
	const std::string& description, T* destination);

template<typename T, typename F>
args::parser& option(const std::string& short_name, const std::string& long_name_or_desc,
	F handler);

template<typename T, typename F>
args::parser& option(const std::string& short_name, const std::string& long_name,
	const std::string& description, F handler);

template<typename T, typename F>
args::parser& option(args::required_t, const std::string& short_name,
	const std::string& long_name_or_desc, F handler);

template<typename T, typename F>
args::parser& option(args::required_t, const std::string& short_name,
	const std::string& long_name, const std::string& description, F handler);
```
</details>

### parser.arg(...) <a id="parser.arg" href="#parser.arg">#</a>

```c++
parser.arg(destination_ptr);
parser.arg<Value_Type>(lambda);
parser.arg([args::required], name, [description], destination_ptr);
parser.arg<Value_Type>([args::required], name, [description], lambda);
```

Specify global positional arguments.

When arguments are passed before command name they are treated as global. If command arguments are already captured or command has no arguments all subsequent arguments will be treated as global.

* `[args::required]` `args::required_t` Set optional marker to make option required
* `name` `std::string` Name used in required errors and help generation
* `description` `std::string` Description used in help generation
* `destination_ptr` `T*` Set option value by pointer
* `lambda` `void (T)` Get option value with lambda

Note! When using `lambda` first template parameter `Value_Type` is required.

All overloads example:

```c++
auto arg = ""s;
auto p = parser{}
	// using destination_ptr
	.arg(&arg)
	.arg("file", &arg)
	.arg("file", "Description", &arg)
	.arg(args::required, "file", &arg)
	.arg(args::required, "file", "Description", &arg)

	// using lambda
	.arg([&](auto v) { arg = v; })
	.arg("file", [&](auto v) { arg = v; })
	.arg("file", "Description", [&](auto v) { arg = v; })
	.arg(args::required, "file", [&](auto v) { arg = v; })
	.arg(args::required, "file", "Description", [&](auto v) { arg = v; })
```

<details>
<summary>All overloads</summary>

```c++
template<typename T>
parser& arg(T* destination);

template<typename T>
parser& arg(const std::string& name, T* destination);

template<typename T>
parser& arg(const std::string& name, const std::string& description, T* destination);

template<typename T>
parser& arg(args::required_t, const std::string& name, T* destination);

template<typename T>
parser& arg(args::required_t, const std::string& name, const std::string& description,
	T* destination);

template<typename T, typename F>
parser& arg(F handler);

template<typename T, typename F>
parser& arg(const std::string& name, F handler);

template<typename T, typename F>
parser& arg(const std::string& name, const std::string& description, F handler);

template<typename T, typename F>
parser& arg(args::required_t, const std::string& name, F handler);

template<typename T, typename F>
parser& arg(args::required_t, const std::string& name, const std::string& description,
	F handler);
```
</details>

### parser.rest(...) <a id="parser.rest" href="#parser.rest">#</a>

```c++
parser.rest(destination_ptr);
parser.rest<Value_Type>(lambda);
parser.rest([args::required], name, [description], destination_ptr);
parser.rest<Value_Type>([args::required], name, [description], lambda);
```

Capture all the rest positional arguments in the container.

* `[args::required]` `args::required_t` Set optional marker to make option required
* `name` `std::string` Name used in required errors and help generation
* `description` `std::string` Description used in help generation
* `destination_ptr` `T*` Set option value by pointer
* `lambda` `void (T)` Get option value with lambda

Note! When using `lambda` first template parameter `Value_Type` is required.

All overloads example:

```c++
auto rest = std::vector<std::string>{};
auto p = parser{}
	// using destination_ptr
	.rest(&rest)
	.rest("cmd", &rest)
	.rest("cmd", "Description", &rest)
	.rest(args::required, "cmd", &rest)
	.rest(args::required, "cmd", "Description", &rest)

	// using lambda
	.rest([&](auto v) { rest = v; })
	.rest("cmd", [&](auto v) { rest = v; })
	.rest("cmd", "Description", [&](auto v) { rest = v; })
	.rest(args::required, "cmd", [&](auto v) { rest = v; })
	.rest(args::required, "cmd", "Description", [&](auto v) { rest = v; })
```

<details>
<summary>All overloads</summary>

```c++
template<typename T>
parser& rest(T* destination);

template<typename T>
parser& rest(const std::string& name, T* destination);

template<typename T>
parser& rest(const std::string& name, const std::string& description, T* destination);

template<typename T>
parser& rest(args::required_t, const std::string& name, T* destination);

template<typename T>
parser& rest(args::required_t, const std::string& name, const std::string& description,
	T* destination);

template<typename T, typename F>
parser& rest(F handler);

template<typename T, typename F>
parser& rest(const std::string& name, F handler);

template<typename T, typename F>
parser& rest(const std::string& name, const std::string& description, F handler);

template<typename T, typename F>
parser& rest(args::required_t, const std::string& name, F handler);

template<typename T, typename F>
parser& rest(args::required_t, const std::string& name
```
</details>

### parser.command(...) <a id="parser.command" href="#parser.command">#</a>

```c++
parser.command(name, [alias], [description], [destination_ptr]);
```

Declare command. Returns command instance that could be used to set commands options, arguments and action.

* `name` `std::string` Command name
* `alias` `std::string` Command alias
* `description` `std::string` Description used in help generation
* `destination_ptr` `bool*` Set to `true` if command is called

Note! When called with only 2 string arguments `alias` must be single word and `description` must be multiple words.

All overloads example:

```c++
auto command_called = false;
auto p = parser{};

// with destination_ptr
p.command("list", &command_called);

p.command("list", "Description must be multi word", &command_called);

p.command("list all", "la", &command_called);

p.command("list", "l", "Description", &command_called);

// with action
p.command("list")
	.action([]() { /* do smt */ });

p.command("list", "Description must be multi word")
	.action([]() { /* do smt */ });

p.command("list all", "la")
	.action([]() { /* do smt */ });

p.command("list", "l", "Description")
	.action([]() { /* do smt */ });
```

<details>
<summary>All overloads</summary>

```c++
command_internal& command(const std::string& name);

command_internal& command(const std::string& name, const std::string& alias_or_desc);

command_internal& command(const std::string& name, const std::string& alias,
	const std::string& description);

command_internal& command(const std::string& name, bool* destination);

command_internal& command(const std::string& name, const std::string& alias_or_desc,
	bool* destination);

command_internal& command(const std::string& name, const std::string& alias,
	const std::string& description, bool* destination);
```
</details>

### command.option(...) <a id="command.option" href="#command.option">#</a>

Same as [parser.option(...)](#parser.option) except it returns command instance.

<details>
<summary>All overloads</summary>

```c++
template<typename T>
command_internal& option(const std::string& name, T* destination);

template<typename T>
command_internal& option(args::required_t, const std::string& name, T* destination);

template<typename T, typename F>
command_internal& option(const std::string& name, F handler);

template<typename T, typename F>
command_internal& option(args::required_t, const std::string& name, F handler);

template<typename T>
command_internal& option(const std::string& short_name, const std::string& long_name_or_desc,
	T* destination);

template<typename T>
command_internal& option(const std::string& short_name, const std::string& long_name,
	const std::string& description, T* destination);

template<typename T>
command_internal& option(args::required_t, const std::string& short_name,
	const std::string& long_name_or_desc, T* destination);

template<typename T>
command_internal& option(args::required_t, const std::string& short_name,
	const std::string& long_name, const std::string& description, T* destination);

template<typename T, typename F>
command_internal& option(const std::string& short_name,
	const std::string& long_name_or_desc, F handler);

template<typename T, typename F>
command_internal& option(const std::string& short_name, const std::string& long_name,
	const std::string& description, F handler);

template<typename T, typename F>
command_internal& option(args::required_t, const std::string& short_name,
	const std::string& long_name_or_desc, F handler);

template<typename T, typename F>
command_internal& option(args::required_t, const std::string& short_name,
	const std::string& long_name, const std::string& description, F handler);
```
</details>

### command.arg(...) <a id="command.arg" href="#command.arg">#</a>

Same as [parser.arg(...)](#parser.arg) except it returns command instance.

<details>
<summary>All overloads</summary>

```c++
template<typename T>
command_internal& arg(T* destination);

template<typename T>
command_internal& arg(const std::string& name, T* destination);

template<typename T>
command_internal& arg(const std::string& name, const std::string& description, T* destination);

template<typename T>
command_internal& arg(args::required_t, const std::string& name, T* destination);

template<typename T>
command_internal& arg(args::required_t, const std::string& name, const std::string& description,
	T* destination);

template<typename T, typename F>
command_internal& arg(F handler);

template<typename T, typename F>
command_internal& arg(const std::string& name, F handler);

template<typename T, typename F>
command_internal& arg(const std::string& name, const std::string& description, F handler);

template<typename T, typename F>
command_internal& arg(args::required_t, const std::string& name, F handler);

template<typename T, typename F>
command_internal& arg(args::required_t, const std::string& name, const std::string& description,
	F handler);
```
</details>

### command.rest(...) <a id="command.rest" href="#command.rest">#</a>

Same as [parser.rest(...)](#parser.rest) except it returns command instance.

<details>
<summary>All overloads</summary>

```c++
template<typename T>
command_internal& rest(T* destination);

template<typename T>
command_internal& rest(const std::string& name, T* destination);

template<typename T>
command_internal& rest(const std::string& name, const std::string& description, T* destination);

template<typename T>
command_internal& rest(args::required_t, const std::string& name, T* destination);

template<typename T>
command_internal& rest(args::required_t, const std::string& name, const std::string& description,
	T* destination);

template<typename T, typename F>
command_internal& rest(F handler);

template<typename T, typename F>
command_internal& rest(const std::string& name, F handler);

template<typename T, typename F>
command_internal& rest(const std::string& name, const std::string& description, F handler);

template<typename T, typename F>
command_internal& rest(args::required_t, const std::string& name, F handler);

template<typename T, typename F>
command_internal& rest(args::required_t, const std::string& name, const std::string& description,
	F handler);
```
</details>

### command.action(lambda) <a id="command.action" href="#command.action">#</a>

Call `lambda` if command is called. Is called after all options and arguments are parsed.

* `lambda` `void ()` Call if command is called

```c++
command_internal& action(std::function<void (void)> action);
```

Example:

```c++
auto p = parser{};

p.command("list")
	.action([]() { /* do smt */ });
```

### parser.parse(argv, argc) <a id="parser.parse" href="#parser.parse">#</a>

Parse options and arguments.

Throws exceptions for invalid options and arguments, unexpected arguments, missing required options, arguments and commands.

* `argv, argc` From `main()` arguments

```c++
void parse(int argc, const char** argv);
```

### Exception: args::invalid\_option <a id="args_invalid_option" href="#args_invalid_option">#</a>

When unregistered option is passed.

Subclass `std::runtime_error`

Properties:

* `option` `std::string`

### Exception: args::invalid\_option\_value <a id="args_invalid_option_value" href="#args_invalid_option_value">#</a>

When failed to parse option value.

Subclass `std::runtime_error`

Properties:

* `option` `std::string`
* `value` `std::string`

### Exception: args::invalid\_command\_option\_value <a id="args_invalid_command_option_value" href="#args_invalid_command_option_value">#</a>

When failed to parse command option value.

Subclass `args::invalid_option_value`

Properties:

* `command` `std::string`
* `option` `std::string`
* `value` `std::string`

### Exception: args::invalid\_arg\_value <a id="args_invalid_arg_value" href="#args_invalid_arg_value">#</a>

When failed to parse argument value.

Subclass `std::runtime_error`

Properties:

* `arg` `std::string`
* `value` `std::string`

### Exception: args::invalid\_command\_arg\_value <a id="args_invalid_command_arg_value" href="#args_invalid_command_arg_value">#</a>

When failed to parse command argument value.

Subclass `args::invalid_arg_value`

Properties:

* `command` `std::string`
* `arg` `std::string`
* `value` `std::string`

### Exception: args::unexpected\_arg <a id="args_unexpected_arg" href="#args_unexpected_arg">#</a>

When non captured arguments is passed.

Subclass `std::runtime_error`

Properties:

* `value` `std::string`

### Exception: args::missing\_command <a id="args_missing_command" href="#args_missing_command">#</a>

When command is required but not passed.

Subclass `std::runtime_error`

Properties:

* `command` `std::string`

### Exception: args::missing\_option <a id="args_missing_option" href="#args_missing_option">#</a>

When option is required but not passed.

Subclass `std::runtime_error`

Properties:

* `option` `std::string`

### Exception: args::missing\_command\_option <a id="args_missing_command_option" href="#args_missing_command_option">#</a>

When command option is required but not passed.

Subclass `args::missing_option`

Properties:

* `command` `std::string`
* `option` `std::string`

### Exception: args::missing\_arg <a id="args_missing_arg" href="#args_missing_arg">#</a>

When positional argument is required but not passed.

Subclass `std::runtime_error`

Properties:

* `arg` `std::string`

### Exception: args::missing\_command\_arg <a id="args_missing_command_arg" href="#args_missing_command_arg">#</a>

When command positional argument is required but not passed.

Subclass `args::missing_arg`

Properties:

* `command` `std::string`
* `arg` `std::string`

### parser.help(lambda) <a id="parser.help" href="#parser.help">#</a>

Custom `--help` handler.

If not present will output generated documentation.

See [custom-help.cpp](https://github.com/wlodzislav/args/blob/master/examples/custom-help.cpp) example.

* `lambda` `void ()` Call if `--help` present

```c++
template<typename F>
parser& help(F help_fun);
```

### parser.format\_help([indent]) -> str <a id="parser.format_help" href="#parser.format_help">#</a>

Return generated documentation.

* `indent` `std::string` Use as indentation for help

```c++
std::string format_help(const std::string& indentation = default_indentation);
```

### parser.format\_command\_help(command\_name, [indent]) -> str <a id="parser.format_command_help" href="#parser.format_command_help">#</a>

Return generated documentation for command.

* `command_name` `std::string` Name of alias of the command
* `indent` `std::string` Use as indentation for help

```c++
std::string format_command_help(const std::string& command_name,
	const std::string& indentation = default_indentation);
```

### parser.format\_usage([indent]) -> str <a id="parser.format_usage" href="#parser.format_usage">#</a>

Return generated usage section.

* `indent` `std::string` Use as indentation for help

```c++
std::string format_usage(const std::string& indentation = default_indentation);
```

### parser.format\_args([indent]) -> str <a id="parser.format_args" href="#parser.format_args">#</a>

Return generated arguments section.

* `indent` `std::string` Use as indentation for help

```c++
std::string format_args(const std::string& indentation = default_indentation);
```

### parser.format\_options([indent]) -> str <a id="parser.format_options" href="#parser.format_options">#</a>

Return generated options section.

* `indent` `std::string` Use as indentation for help

```c++
std::string format_options(const std::string& indentation = default_indentation);
```

### parser.format\_commands([indent]) -> str <a id="parser.format_commands" href="#parser.format_commands">#</a>

Return generated commands section.

* `indent` `std::string` Use as indentation for help

```c++
std::string format_commands(const std::string& indentation = default_indentation);
```

### parser.format\_command\_usage(command\_name, [indent]) -> str <a id="parser.format_command_usage" href="#parser.format_command_usage">#</a>

Return generated command usage section.

* `command_name` `std::string` Name of alias of the command
* `indent` `std::string` Use as indentation for help

```c++
std::string format_command_usage(const std::string& command_name,
	const std::string& indentation = default_indentation);
```

### parser.format\_command\_args(command\_name, [indent]) -> str <a id="parser.format_command_args" href="#parser.format_command_args">#</a>

Return generated command args section.

* `command_name` `std::string` Name of alias of the command
* `indent` `std::string` Use as indentation for help

```c++
std::string format_command_args(const std::string& command_name,
	const std::string& indentation = default_indentation);

```

### parser.format\_command\_options(command\_name, [indent]) -> str <a id="parser.format_command_options" href="#parser.format_command_options">#</a>

Return generated command options section.

* `command_name` `std::string` Name of alias of the command
* `indent` `std::string` Use as indentation for help

```c++
std::string format_command_options(const std::string& command_name,
	const std::string& indentation = default_indentation);
```

